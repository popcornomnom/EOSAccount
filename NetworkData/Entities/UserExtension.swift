//
//  User.swift
//  NetworkData
//
//  Created by Marharyta Lytvynenko on 17.11.2019.
//  Copyright (c) 2019 Marharyta Lytvynenko. All rights reserved.
//
//  This file was generated by http://www.popcornomnom.com
//

import Foundation
import Domain

extension User: EntityType {
    
    enum Key: CodingKey {
        case account_name
        case core_liquid_balance
        case total_resources
        case net_limit, cpu_limit
        case ram_quota
        case ram_usage
        case self_delegated_bandwidth
        case voter_info
    }
    
    enum VoterInfoKey: CodingKey {
        case staked
    }
    
    enum LimitKey: CodingKey {
        case used, available, max
    }
    
    enum SelfDelegatedBandwidthKey: CodingKey {
        case net_weight, cpu_weight
    }
    
    public convenience init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: Key.self)
        let selfDelegatedContainer = try container
            .nestedContainer(keyedBy: SelfDelegatedBandwidthKey.self,
                             forKey: .self_delegated_bandwidth)
        guard let unstaked = Double(try container.decode(String.self,
                                                        forKey: .core_liquid_balance)
            .split(separator: " ").first ?? ""),
            let cpuStaked = Double(try selfDelegatedContainer.decode(String.self,
                                                                    forKey: .cpu_weight)
                .split(separator: " ").first ?? ""),
        let netStaked = Double(try selfDelegatedContainer.decode(String.self,
                                                                forKey: .net_weight)
            .split(separator: " ").first ?? "") else {
                throw ApiError.incorrectAccountResponce
        }
        
        let voterInfoContainer = try container
            .nestedContainer(keyedBy: VoterInfoKey.self,
                             forKey: .voter_info)
        let staked = try voterInfoContainer.decode(Double.self, forKey: .staked) / 10_000
        let fullname = try container.decode(String.self, forKey: .account_name)
        let cpuLimitContainer = try container
            .nestedContainer(keyedBy: LimitKey.self,
                             forKey: .cpu_limit)
        let cpuUsed = try cpuLimitContainer.decode(Domain.Сonsumption.T.self,
                                                   forKey: .used)
        let cpuAvailable = try cpuLimitContainer.decode(Domain.Сonsumption.T.self,
                                                        forKey: .available)
        let cpuTotal = try cpuLimitContainer.decode(Domain.Сonsumption.T.self,
                                                    forKey: .max)
        let cpu = Domain.Сonsumption(used: cpuUsed / 1_000,
                                      available: cpuAvailable / 1_000,
                                      total: cpuTotal / 1_000,
                                      type: .s)
        let netLimitContainer = try container
            .nestedContainer(keyedBy: LimitKey.self,
                             forKey: .net_limit)
        let netUsed = try netLimitContainer.decode(Domain.Сonsumption.T.self,
                                                   forKey: .used)
        let netAvailable = try netLimitContainer.decode(Domain.Сonsumption.T.self,
                                                        forKey: .available)
        let netTotal = try netLimitContainer.decode(Domain.Сonsumption.T.self,
                                                    forKey: .max)
        let net = Domain.Сonsumption(used: netUsed / 1_000,
                                      available: netAvailable / 1_000,
                                      total: netTotal / 1_000,
                                      type: .kb)
        
        let ramUsed = try container.decode(Double.self,
                                           forKey: .ram_usage)
        let ramTotal = try container.decode(Double.self,
                                            forKey: .ram_quota)
        let ram = Domain.Сonsumption(used: ramUsed / 1_000,
                                      available: netAvailable / 1_000,
                                      total: ramTotal / 1_000,
                                      type: .kb)
        self.init(fullname: fullname,
                  netSelfStaked: netStaked, cpuSelfStaked: cpuStaked,
                  balance: Balance(unstaked: unstaked, staked: staked),
                  net: net, cpu: cpu, ram: ram)
    }
}
